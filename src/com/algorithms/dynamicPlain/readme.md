# 动态规划的三步

###1 .明确dp数组的含义
dp数组是帮我们把问题规模缩小的关键。对于公共子序列的问题，如果是两个字符串，那么
pd数组一般都是二维的。套路都是通用的，如下。
```java
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        dp[i][j] = min/max(dp)
    }
}
```
对于最长公共子序列的问题，dp[i][j]就表示长度为i,j的两个字符串的最长子序列。

### 2. 明确base
明确base条件。也就是初始的条件。当问题规模是1或者0时的解。

### 3. 找到状态转移方程。

状态转移方程是将子问题和初始问题结合起来的关键，同时这两个问题之间是无后效性的。也就是不先关的。
这一步也是动态规划中最难的，状态转移的一个思路是找到里面能进行的选择。例如最长公共子序列的问题
S1,S2的最长公共子序列，对于其中的每个字符，s1,s2是有两种选择的，要么在最长公共子序列lcs中
要么不在。【在】/【不在】

如果在，那么肯定两个字符串中都有，存在S1[i]==S2[j],那么S1[i-1]S2[j-1]这个子问题中如果知道最长
的序列，那么+1,就能得到。
而如果不在，那么就是S[i]！=S[j],那么长度为i,j的两个串的lcs，就一定在i-1,j的两个串和i,j-1的两个串
中取最长的。


### 子序列问题模板

子序列问题考的都是动态规划的技巧，其实现复杂度一般都是O(n^2)的

两种思路

#### 1. dp数组是一维的，只涉及一个字符串
例如字符串只有一个的问题常用这种。其模板是：

    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(condation)
                dp[i] = 最值(dp[i],dp[j]+...)
        }
    }

例如最长递增子序列，回文数就是这个思路。

#### 2. dp数组是二维的，涉及两个字符串。

例如有两个字符串的，其模板是

    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(aar[i]==aar[j])
                dp[i][j] = dp[i][j]+...
            else
                dp[i][j] = 最值(...)
        }
    }
    

这类题目，例如，最长公共子序列，